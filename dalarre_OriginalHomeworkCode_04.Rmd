---
title: "dalarre_OriginalHomeworkCode_04"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.



## HOMEWORK 4

## 1: Write a simple R function, Z.prop.test(), that can perform one- or two-sample Z-tests for proportion data

```{r}

z.prop.test <- function(p1, n1, p2 = NULL, n2 = NULL, p0, alternative = "two.sided", conf.level = 0.95) {

  ## For 1 sample
  if (is.null(p2) == TRUE || is.null(n2) == TRUE) {
    
    z <- (p1 - p0)/sqrt(p0 * (1 - p0)/n1) ## Defines Z
    lower <- p1 - qnorm(1-(1-conf.level)/2) * sqrt(p1 * (1 - p1)/n1)
    upper <- p1 + qnorm(1-(1-conf.level)/2) * sqrt(p1 * (1 - p1)/n1)
    ci <- c(lower, upper) ## Defines the CI
    
    if(n1*p1 < 5 || n1*(1-p1) < 5) {
      print("Your sample does not follow the rules of thumb (n∗p>5 and n∗(1−p)>5")
    } ## If the thumb rules are violated this message warns you
    
    
    ## Now I define p for each type of test
    
    if (alternative == "less") {
      p <- pnorm(z, lower.tail = TRUE)
      
    }
    
    if (alternative == "greater") {
      p <- pnorm(z, lower.tail = FALSE)
      
    }
    
    if (alternative == "two.sided") {
      
      if (z > 0) {
        p <- 2 * pnorm(z, lower.tail = FALSE)
      }  
      
      if (z < 0)
                {
        p <- 2 * pnorm(z, lower.tail = TRUE)
                } 
      
    }
  }
 
  ## For 2 samples
  if (is.null(p2) == FALSE && is.null(n2) == FALSE) {
    
    pooledp <- (p1*n1+p2*n2)/(n1+n2)
    z <- ((p2 - p1) - p0)/sqrt((pooledp * (1 - pooledp)) * (1/n1 + 1/n2)) ## Defines Z
    lower <- (p2-p1) - qnorm(1-(1-conf.level)/2) * sqrt((p1 * (1 - p1)/n1)+(p2 * (1 - p2)/n2))
    upper <- (p2-p1) + qnorm(1-(1-conf.level)/2) * sqrt((p1 * (1 - p1)/n1)+(p2 * (1 - p2)/n2))
    ci <- c(lower, upper) ## Defines the CI
    ## How to do a difference between two proportions confidence interval taken from https://www.dummies.com/education/math/statistics/how-to-estimate-the-difference-between-two-proportions/
    
    if(n1*p1 < 5 || n1*(1-p1) < 5 || n2*p2 < 5 || n2*(1-p2) < 5) {
      print("Your sample does not follow the rules of thumb (n∗p>5 and n∗(1−p)>5")
    }
    
    
    ## Now I define p for each type of test
    
    if (alternative == "less") {
      p <- pnorm(z, lower.tail = TRUE)
      
    }
    
    if (alternative == "greater") {
      p <- pnorm(z, lower.tail = FALSE)
      
    }
    
    if (alternative == "two.sided") {
      
      if (z > 0) {
        p <- 2 * pnorm(z, lower.tail = FALSE)
      }  
      
      if (z < 0)
                {
        p <- 2 * pnorm(z, lower.tail = TRUE)
                } 
      
    }
  }
    
  return(list(z,p,ci)) ## The function retuns a list with the Z value, the p value and the CI
}

```

```{r}
## here I run tests to see if all the features of the function work

    z.prop.test(p1 = 0.6, n1 = 30, p0 = 0.5, conf.level = 0.95) 
    z.prop.test(p1 = 0.6, n1 = 5, p0 = 0.5, alternative = "less", conf.level = 0.95)
    z.prop.test(p1 = 0.6, n1 = 30, p0 = 0, p2 = 0.8, n2 = 25, conf.level = 0.95)
    z.prop.test(p1 = 0.6, n1 = 30, p0 = 0.4, n2 = 25, conf.level = 0.95)
    z.prop.test(p1 = 0.6, n1 = 50, p0 = 0, p2 = 0.8, n2 = 60, alternative = "greater", conf.level = 0.95)
    
## It seems to work in every circumstance
    
```

## 2: Fit a simple linear regression model to predict longevity (MaxLongevity_m) measured in months from species’ brain size (Brain_Size_Species_Mean) measured in grams.

```{r}

library(curl)
f <- curl("https://raw.githubusercontent.com/fuzzyatelin/fuzzyatelin.github.io/master/AN588_Fall21/KamilarAndCooperData.csv")
d <- read.csv(f, header = TRUE, sep = ",", stringsAsFactors = FALSE)
head(d)
names(d)
## This loads the data

```
```{r}

library(ggplot2)

m <- lm(MaxLongevity_m ~ Brain_Size_Species_Mean, data = d)
m
## With this I obtain the intercept and slope of the regrssion line

## This plots longevity against brain size
longevity_brainsize <- ggplot(d, aes(MaxLongevity_m, Brain_Size_Species_Mean)) + geom_point(color = "darkgreen") + xlab("Longevity") + ylab("Brain size") + geom_smooth(method = lm) + geom_text(label = "y = 1.218*x + 248.952")

longevity_brainsize

## I don't know how to use geom_text to not put the ecuation on every point, help!


l <- log(d$MaxLongevity_m) 
b <- log(d$Brain_Size_Species_Mean)

f <- cbind(d, l, b)
head(f)
names(f)

n <- lm(l ~ b, data = f)
n

## This plots log(longevity) against log(brain size)
log_longevity_brainsize <- ggplot(d, aes(l, b)) + geom_point(color = "darkgreen") + xlab("log(Longevity)") + ylab("log(Brain size)") + geom_smooth(method = lm) + geom_text(label = "y = 0.2341*x + 4.8790")

log_longevity_brainsize

## Same problem as before, I dont know how to use geom_text


```

```{r}

summary(m)
## The point estimate of the slope is 1.2180

t <- coef(summary(m))
t <- data.frame(unlist(t))
colnames(t) <- c("Est", "SE", "t", "p")
t
## The p-values (last colum of the t data frame) are really small - there is significant evidence that the slope isn't = 0 (we reject the null hypothesis)

ci_m <- confint(m, level = 0.9)  # This calculates the CIs for the slope (β1) parameter.
ci_m

summary(n)
## The point estimate of the slope is 0.23415

u <- coef(summary(n))
u <- data.frame(unlist(u))
colnames(u) <- c("Est", "SE", "t", "p")
u
## The p-values (last colum of the t data frame) are really small - there is significant evidence that the slope isn't = 0 (we reject the null hypothesis)

ci_n <- confint(n, level = 0.9)  # This calculates the CIs for the slope (β1) parameter.
ci_n

```
```{r}


longevity_brainsize2 <- ggplot(d, aes(MaxLongevity_m, Brain_Size_Species_Mean)) + geom_point(color = "darkgreen") + xlab("Longevity") + ylab("Brain size") + geom_smooth(method = lm, level = 0.9, colour = "red", show.legend = TRUE)+ geom_smooth(method = lm, level = 0.95, colour = "lightblue", show.legend = TRUE)

longevity_brainsize2


log_longevity_brainsize2 <- ggplot(d, aes(l, b)) + geom_point(color = "darkgreen") + xlab("log(Longevity)") + ylab("log(Brain size)") + geom_smooth(method = lm, show.legend = TRUE) + geom_smooth(method = lm, level = 0.9, colour = "red", show.legend = TRUE)

log_longevity_brainsize2

## This creates plots with both the 90% and the 95% CIs. I have problems showing the legend
```
```{r}

## Me queda inferir a partir de 800 gramos desde la lineal y la del logaritmo, decidir cual es mejor y hacer lo de los 5 challenges encontrados.

```










